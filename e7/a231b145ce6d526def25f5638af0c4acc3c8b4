X-Spam-Checker-Version: SpamAssassin 3.3.2 (2011-06-06) on dcvr.yhbt.net
X-Spam-Level: 
X-Spam-ASN: AS14383 205.234.109.0/24
X-Spam-Status: No, score=-0.5 required=5.0 tests=AWL,MSGID_FROM_MTA_HEADER,
 RP_MATCHES_RCVD shortcircuit=no autolearn=unavailable version=3.3.2
Path: news.gmane.org!not-for-mail
From: Eric Wong <normalperson@yhbt.net>
Newsgroups: gmane.comp.lang.ruby.unicorn.general
Subject: Re: What happens when a client terminates a connection?
Date: Mon, 8 Aug 2011 14:47:29 -0700
Message-ID: <20110808214729.GA4419@dcvr.yhbt.net>
References: <20110808193252.GA7188@dcvr.yhbt.net>
 <20110808211748.GB49840@jessebook-2.local>
NNTP-Posting-Host: lo.gmane.org
Mime-Version: 1.0
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit
X-Trace: dough.gmane.org 1312840081 6744 80.91.229.12 (8 Aug 2011 21:48:01
 GMT)
X-Complaints-To: usenet@dough.gmane.org
NNTP-Posting-Date: Mon, 8 Aug 2011 21:48:01 +0000 (UTC)
To: unicorn list <mongrel-unicorn@rubyforge.org>
Original-X-From: mongrel-unicorn-bounces@rubyforge.org Mon Aug 08 23:47:56
 2011
Return-path: <mongrel-unicorn-bounces@rubyforge.org>
Envelope-to: gclrug-mongrel-unicorn@m.gmane.org
X-Original-To: mongrel-unicorn@rubyforge.org
Delivered-To: mongrel-unicorn@rubyforge.org
Content-Disposition: inline
In-Reply-To: <20110808211748.GB49840@jessebook-2.local>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-BeenThere: mongrel-unicorn@rubyforge.org
X-Mailman-Version: 2.1.12
Precedence: list
List-Id: <unicorn-public@bogomips.org>
List-Unsubscribe: <http://rubyforge.org/mailman/options/mongrel-unicorn>,
 <mailto:mongrel-unicorn-request@rubyforge.org?subject=unsubscribe>
List-Archive: <http://rubyforge.org/pipermail/mongrel-unicorn>
List-Post: <unicorn-public@bogomips.org>
List-Help: <mailto:mongrel-unicorn-request@rubyforge.org?subject=help>
List-Subscribe: <http://rubyforge.org/mailman/listinfo/mongrel-unicorn>,
 <mailto:mongrel-unicorn-request@rubyforge.org?subject=subscribe>
Original-Sender: mongrel-unicorn-bounces@rubyforge.org
Errors-To: mongrel-unicorn-bounces@rubyforge.org
Xref: news.gmane.org gmane.comp.lang.ruby.unicorn.general:1094
Archived-At:
 <http://permalink.gmane.org/gmane.comp.lang.ruby.unicorn.general/1094>
Received: from rubyforge.org ([205.234.109.19]) by lo.gmane.org with esmtp
 (Exim 4.69) (envelope-from <mongrel-unicorn-bounces@rubyforge.org>) id
 1QqXfw-0001H8-Fl for gclrug-mongrel-unicorn@m.gmane.org; Mon, 08 Aug 2011
 23:47:56 +0200
Received: from rubyforge.org (rubyforge.org [127.0.0.1]) by rubyforge.org
 (Postfix) with ESMTP id EA9FE18583A5; Mon,  8 Aug 2011 17:47:55 -0400 (EDT)
Received: from dcvr.yhbt.net (dcvr.yhbt.net [64.71.152.64]) by rubyforge.org
 (Postfix) with ESMTP id EE2CA185838E for <mongrel-unicorn@rubyforge.org>;
 Mon,  8 Aug 2011 17:47:29 -0400 (EDT)
Received: from localhost (dcvr.yhbt.net [127.0.0.1]) by dcvr.yhbt.net
 (Postfix) with ESMTP id 4AD6021060; Mon,  8 Aug 2011 21:47:29 +0000 (UTC)

Jesse Storimer <jstorimer@gmail.com> wrote:
> Eric Wong <normalperson@yhbt.net> wrote:
> > Unicorn has 4 distinct states :

<snip>

> > 3) inside Rack dispatch (after rack.input reading)
> >    Your app has no way of knowing your client disconnected at
> >    this stage.  You can hack Unicorn to IO.select in a separate
> >    thread, but there'll always be exposed windows leading up to
> >    4) so it's not worth it...
> > 
> > 4) writing the response: Unicorn will abort whenever a socket
> >    error is detected.  Keep in mind that every single part of the
> >    Rack response array can be dynamically generated by the app.
> >    Your application can still be "running" even though the Rack app
> >    has returned its response for Unicorn to start writing.
> > 
> >    Clients/Rack middleware can be written to detect this in the
> >    response body "close" method by checking if body.each completed.
> 
> Thanks for that explanation. Just so I understand, once the Rack application 
> enters 3) then it should be unaffected by a client disconnect, or any
> socket error? I'll definitely give PrereadInput a try in that case.

Yes, however I don't think I made it clear that 3) will /always/ transition
to state 4).  So you'll be able to use body.close to detect a client
write failure.

> When you say that Unicorn lazily reads request bodies, do you mean that
> my Rails application might already be in the middle of processing the
> request but Unicorn is still reading from the client socket?

Yes.  We use http://unicorn.bogomips.org/Unicorn::TeeInput.html by
default so it gives the Rack app a chance to reject a client
if it sees something it doesnt like

> At that point won't Rails have read all of the request body? Or does
> that only apply if I stick a middleware at the front of the stack that
> does all the heavy lifting?

I'm not certain about middlewares.  Rails may attempt to read all input
ASAP anyways depending on the request Content-Type/Encoding.  Check the
Rails/Rack sources for your versions of Rails/Rack to be sure.

-- 
Eric Wong
_______________________________________________
Unicorn mailing list - mongrel-unicorn@rubyforge.org
http://rubyforge.org/mailman/listinfo/mongrel-unicorn
Do not quote signatures (like this one) or top post when replying

